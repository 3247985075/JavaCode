# JavaCode
I specifically cover the following topics: Java primitive data types, declaration statements, expression statements, importing class libraries, excepting user input, checking for valid input, catching errors in input, math functions, if statement, relational operators, logical operators, ternary operator, switch statement, and looping.   How class variables differ from local variables, Java Exception handling, the difference between run time and checked exceptions, Arrays, and UML Diagrams.  Monsters gameboard, Java collection classes, Java ArrayLists, Linked Lists, manipulating Strings and StringBuilders, Polymorphism, Inheritance, Protected, Final, Instanceof, interfaces, abstract classes, abstract methods.  You need interfaces and abstract classes because Java doesn't allow you to inherit from more than one other class.  Java threads, Regular Expressions, Graphical User Interfaces (GUI) using Java Swing and its components, GUI Event Handling, ChangeListener, JOptionPane, combo boxes, list boxes, JLists, DefaultListModel, using JScrollpane with JList, JSpinner, JTree, Flow, Border, and Box Layout Managers.  Created a calculator layout with Java Swing's GridLayout, GridBagLayout, GridBagConstraints, Font, and Insets.  JLabel, JTextField, JComboBox, JSpinner, JSlider, JRadioButton, ButtonGroup, JCheckBox, JTextArea, JScrollPane, ChangeListener, pack, create and delete files and directories. How to pull lists of files from directories and manipulate them, write to and read character streams from files. PrintWriter, BufferedWriter, FileWriter, BufferedReader, FileReader, common file exceptions  Binary Streams - DataOutputStream, FileOutputStream, BufferedOutputStream, all of the reading and writing primitive type methods, setup Java JDBC in Eclipse, connect to a MySQL database, query it and get the results of a query.  JTables, JEditorPane Swing component. HyperlinkEvent and HyperlinkListener.  Java JApplet, Java Servlets with Tomcat, GET and POST methods, Java Server Pages, parsing XML with Java, Java XPath, JDOM2 library, and 2D graphics.   *Created a Java Paint Application using swing, events, mouse events, Graphics2D, ArrayList  *Designed a Java Video Game like Asteroids with collision detection and shooting torpedos which also played sound in a JFrame, and removed items from the screen when they were destroyed.  Rotating polygons, and Making Java Executable.  Model View Controller (MVC) The Model is the class that contains the data and the methods needed to use the data. The View is the interface. The Controller coordinates interactions between the Model and View.  DESIGN PATTERNS:  Strategy design patternis used if you need to dynamically change an algorithm used by an object at run time. The pattern also allows you to eliminate code duplication. It separates behavior from super and subclasses.  The Observer pattern is a software design pattern in which an object, called the subject (Publisher), maintains a list of its dependents, called observers (Subscribers), and notifies them automatically of any state changes, usually by calling one of their methods.  The Factory design pattern is used when you want to define the class of an object at runtime. It also allows you to encapsulate object creation so that you can keep all object creation code in one place  The Abstract Factory Design Pattern is like a factory, but everything is encapsulated.  The Singleton pattern is used when you want to eliminate the option of instantiating more than one object. (Scrabble letters app)  The Builder Design Pattern is used when you want to have many classes help in the creation of an object. By having different classes build the object you can then easily create many different types of objects without being forced to rewrite code. The Builder pattern provides a different way to make complex objects like you'd make using the Abstract Factory design pattern.  The Prototype design pattern is used for creating new objects (instances) by cloning (copying) other objects. It allows for the adding of any subclass instance of a known super class at run time. It is used when there are numerous potential classes that you want to only use if needed at runtime. The major benefit of using the Prototype pattern is that it reduces the need for creating potentially unneeded subclasses.  Java Reflection is an API and it's used to manipulate classes and everything in a class including fields, methods, constructors, private data, etc. (TestingReflection.java)  The Decorator allows you to modify an object dynamically. You would use it when you want the capabilities of inheritance with subclasses, but you need to add functionality at run time. It is more flexible than inheritance. The Decorator Design Pattern simplifies code because you add functionality using many simple classes. Also, rather than rewrite old code you can extend it with new code and that is always good. (Pizza app)  The Command design pattern allows you to store a list of commands for later use. With it you can store multiple commands in a class to use over and over. (ElectronicDevice app)  The Adapter pattern is used when you want to translate one interface of a class into another interface. Allows 2 incompatible interfaces to work together. It allows the use of the available interface and the target interface. Any class can work together as long as the Adapter solves the issue that all classes must implement every method defined by the shared interface. (EnemyAttacker app)   The Facade pattern basically says that you should simplify your methods so that much of what is done is in the background. In technical terms you should decouple the client from the sub components needed to perform an operation. (Bank app)  The Bridge Pattern is used to decouple an abstraction from its implementation so that the two can vary independently. Progressively adding functionality while separating out major differences using abstract classes. (EntertainmentDevice app)  In a Template Method pattern, you define a method (algorithm) in an abstract class. It contains both abstract methods and non-abstract methods. The subclasses that extend this abstract class then override those methods that don't make sense for them to use in the default way. (Sandwich app)  The Iterator pattern provides you with a uniform way to access different collections of Objects. You can also write polymorphic code because you can refer to each collection of objects because they'll implement the same interface. (SongIterator app)  The Composite design pattern is used to structure data into its individual parts as well as represent the inner workings of every part of a larger object. The composite pattern also allows you to treat both groups of parts in the same way as you treat the parts polymorphically. You can structure data, or represent the inner working of every part of a whole object individually. (SongComponent app)  The flyweight design pattern is used to dramatically increase the speed of your code when you are using many similar objects. To reduce memory usage the flyweight design pattern shares Objects that are the same rather than creating new ones. (FlyWeightTest app)  State Pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. (ATMState)  The Proxy design pattern limits access to just the methods you want made accessible in another class. It can be used for security reasons, because an Object is intensive to create, or is accessed from a remote location. You can think of it as a gate keeper that blocks access to another Object. (TestATMMachine)  The Chain of Responsibility pattern has a group of objects that are expected to between them be able to solve a problem. If the first Object can't solve it, it passes the data to the next Object in the chain. (TestCalcChain)  The Interpreter pattern is used to convert one representation of data into another. The context cantains the information that will be interpreted. The expression is an abstract class that defines all the methods needed to perform the different conversions. The terminal or concrete expressions provide specific conversions on different types of data. (MeasurementConversion)  The Mediator design pattern is used to handle communication between related objects (Colleagues). All communication is handled by a Mediator Object and the Colleagues don't need to know anything about each other to work together. (TestStockMediator)  The Memento design pattern provides a way to store previous states of an Object easily. It has 3 main classes: 1) Memento: The basic object that is stored in different states.  2) Originator: Sets and Gets values from the currently targeted Memento. Creates new Mementos and assigns current values to them.  3) Caretaker: Holds an ArrayList that contains all previous versions of the Memento. It can store and retrieve stored Mementos. (TestMemento)  The Visitor design pattern allows you to add methods to classes of different types without much altering to those classes. You can make completely different methods depending on the class used with this pattern. (VisitorTest)
